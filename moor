#!/usr/bin/env moon
----- mooni -----
-- A basic MoonScript REPL
--
parse = require "moonscript.parse"
compile = require "moonscript.compile"
append = table.insert

------- a useful table dumper ------

quote  = (v) ->
	if type(v) == 'string'
		'%q'\format(v)
	else
		tostring(v)

dump = (t, options) ->
	options = options or {}
	limit = options.limit or 1000
	buff = tables:{[t]:true}
	k, tbuff = 1, nil

	put = (v) ->
		buff[k] = v
		k += 1

	put_value = (value) ->
		unless type value == 'table'
			put quote value
			if limit and k > limit
				buff[k] = "..."
				error "buffer overrun"
		else
			if buff.tables[value] -- cycle detection
				put "<cycle>"
			else
				buff.tables[value] = true
				tbuff value
		put ', '

	tbuff = (t) ->
		mt = getmetatable t unless options.raw
		if type(t) != 'table' or mt and mt.__tostring
			put quote t
		else
			put '{'
			indices = #t > 0 and {i, true for i = 1, #t}
			for key, value in pairs t -- first do the hash part
				continue if indices and indices[key]

				if type key != 'string' then
					key = '['..tostring(key)..']'
				elseif key\match '%s'
					key = quote key
				put key..':'
				put_value value
			if indices -- then bang out the array part
				for v in *t
					put_value v
			if buff[k - 1] == ", " then k -= 1
			put '}'

	-- we pcall because that's the easiest way to bail out if there's an overrun.
	pcall tbuff, t
	table.concat buff

---- tab-completion logic from luaish ------------

ok, linenoise = pcall require, 'linenoise'

is_pair_iterable = (t) -> type(t) == 'table'

lua_candidates = (line) ->
  -- identify the expression!
	i1 = line\find '[.\\%w_]+$'
	if i1 == nil then return
	front = line\sub 1, i1 - 1
	partial = line\sub i1
	prefix, last = partial\match '(.-)([^.\\]*)$'
	t, all = _G
	if #prefix > 0
		P = prefix\sub 1, -2
		all = last == ''

		for w in P\gmatch '[^.\\]+'
			t = t[w]
			unless t then return

	prefix = front .. prefix

	res = {}
	append_candidates = (t) ->
		for k in pairs t
			if all or k\sub(1, #last) == last
				append res, prefix..k

	if is_pair_iterable t then append_candidates t
	mt = getmetatable t
	if mt and is_pair_iterable mt.__index then append_candidates mt.__index
	return res

completion_handler = (c, s) ->
	cc = lua_candidates s
	if cc
		for name in *cc do linenoise.addcompletion c, name

-- need to keep track of what globals have been added during the session
oldg = {k, v for k, v in pairs _G}
_G._FOO = true

-- (this will return their names)
newglobs = -> [k for k in pairs _G when not oldg[k]]

chopline = (txt) -> txt\gsub '^[^\n]+\n', '', 1
firstline = (txt) -> txt\match '^[^\n]*'

mytostring = tostring

capture = (ok, ...) ->
	t = {...}
	t.n = select '#', ...
	return ok, t

eval_lua = (lua_code) ->
	chunk, err = loadstring lua_code, 'tmp'
	if err -- Lua compile error is rare!
		print err
		return
	ok, res = capture pcall chunk
	if not ok -- runtime error
		print res[1]
		return
	elseif #res > 0
		-- this allows for overriding basic value printing
		_G._l = res[1] -- save last value calculated
		out = [mytostring res[i] for i = 1, res.n]
		io.write table.concat(out, '\t'), '\n'

old_lua_code = nil

eval_moon = (moon_code) ->
	-- Ugly fiddle #2: we force Moonscript code to regard
	-- any _new_ globals as known globals
	locs = 'local '..table.concat(newglobs!, ', ')
	moon_code = locs..'\n'..moon_code
	tree, err = parse.string moon_code
	if not tree
		print err
		return
	lua_code, err, pos = compile.tree tree
	if not lua_code
		print compile.format_error err, pos, moon_code
		return
	-- our code is ready
	-- Fiddle #2 requires us to lose the top local declarations we inserted
	lua_code = chopline lua_code
	-- Fiddle #1 Moonscript will of course declare any new variables
	-- as local. This fiddle removes the 'local'
	was_local, rest = lua_code\match '^local (%S+)(.+)'
	if was_local
		if rest\match '\n' then rest = firstline rest
		-- two cases; either a direct local assignmnent or a declaration line
		if rest\match '='
			lua_code = lua_code\gsub '^local%s+', ''
		else
			lua_code = chopline lua_code
	old_lua_code = lua_code
	eval_lua lua_code

---- parsing command line -------
print "moor on MoonScript version " .. (require "moonscript.version").version .. " on " .. _VERSION

i = 0
nexta = ->
	i += 1
	arg[i]

while true
	a = nexta!
	break unless a
	flag, rest = a\match '^%-(%a)(%S*)'
	if flag == 'l'
		lib = (rest and #rest > 0) and rest or nexta!
		require lib
	elseif flag == 'e'
		eval_moon nexta!
		os.exit!
	else
		print "Usage: moonr[options] \n\n    -e string  execute string as MoonScript code\n    -l lib     load library before run moonr REPL\n"
		os.exit!


mytostring = dump
_G.tstring = mytostring

prompt = '> '
indent = ""
local get_line

if ok
	linenoise.setcompletion completion_handler
	addhistory = linenoise.addhistory or linenoise.historyadd
	get_line = ->
		line = linenoise.linenoise prompt .. indent
		if line and line\match '%S'
			addhistory line
		line
else
	get_line = ->
		io.write prompt .. indent
		io.read!


rex = require "rex_posix"

is_blockstart = (line) ->
	return rex.match line, "for|while|repeat|if|elseif|class|[=-]>"


while true
	line = get_line!
	if not line then break
	-- a line ending with a tab or a backslash starts a block
	if is_blockstart line
		code = {line}
		indent ..= " "
		line = get_line!
		while #line > 0
			append code, indent .. line
			line = get_line!
		code = table.concat code, '\n'
		prompt = '> '
		indent = ''
		eval_moon code
	elseif line\match '^%?que'
		print old_lua_code
	else
		eval_moon line

