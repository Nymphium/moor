local printerr, to_lua, evalprint
do
  local _obj_0 = require('moor')
  printerr, to_lua, evalprint = _obj_0.printerr, _obj_0.to_lua, _obj_0.evalprint
end
local eval_moon
eval_moon = function(txt)
  local lua_code, err = to_lua(txt)
  if err then
    return nil, err
  else
    return evalprint(lua_code)
  end
end
local nextagen
nextagen = function(self)
  return function()
    return table.remove(self, 1)
  end
end
local msg
msg = function()
  io.write('Usage: moonr [options]\n', '\n', '   -h         print this message\n', '   -n         continue running REPL after "e" option completed\n', '   -e STR     execute string as MoonScript code\n', '   -l LIB     load library before run REPL\n', '   -L LIB     execute `LIB = require"LIB"` before run REPL\n', '\n')
  return os.exit(1)
end
return function(env, args)
  local repl_flag, earg, oneshot
  local nexta = nextagen(args)
  while true do
    local a = nexta()
    if not (a) then
      break
    end
    local flag, rest = a:match('^%-(%a)(%S*)')
    local _exp_0 = flag
    if 'l' == _exp_0 then
      local ok, err = pcall(require, #rest > 0 and rest or nexta())
      if not (ok) then
        printerr(err, '\n')
        msg()
      end
    elseif 'L' == _exp_0 then
      local lib = #rest > 0 and rest or nexta()
      local ok, cont = pcall(require, lib)
      if not (ok) then
        printerr(cont, '\n')
        msg()
      else
        env[rest] = cont
      end
    elseif 'n' == _exp_0 then
      repl_flag = true
    elseif 'e' == _exp_0 then
      earg = true
      oneshot = true
      local ok, err = pcall(eval_moon, (#rest > 0 and rest or nexta()))
      if not (ok) then
        printerr(err)
        msg()
      end
    else
      msg()
    end
  end
  if not (earg) then
    printerr("moor on MoonScript version " .. tostring((require('moonscript.version')).version) .. " on " .. tostring(_VERSION))
  end
  return repl_flag or not oneshot
end
