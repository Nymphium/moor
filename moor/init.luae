local parse = require('moonscript.parse')
local compile = require('moonscript.compile')
local ln = require('linenoise')
local inspect = require('inspect')
local remove, insert, concat
do
  local _obj_0 = table
  remove, insert, concat = _obj_0.remove, _obj_0.insert, _obj_0.concat
end
local printerr
printerr = function(...)
  return io.stderr:write(tostring(concat({
    ...
  }, "\t")) .. "\n")
end
local prompt = {
  p = ">",
  deepen = function(self)
    self.p = "? "
  end,
  reset = function(self)
    self.p = ">"
  end
}
local to_lua
to_lua = function(code)
  local tree, err = parse.string(code)
  if err then
    return nil, err
  else
    local lua_code, pos
    lua_code, err, pos = compile.tree(tree)
    if not (lua_code) then
      return nil, compile.format_error(err, pos, code)
    else
      return lua_code
    end
  end
end
local evalprint
evalprint = function(misglobal, lua_code)
  if lua_code:match("^local%s+%w+") then
    local varname, rest = lua_code:match("^local%s+(%w+)%s*(.*)$")
    if rest:match("^=") then
      lua_code = varname .. rest
    else
      lua_code = rest
    end
    insert(misglobal, varname)
  end
  local luafn, err = loadstring(lua_code, "tmp")
  if err then
    return printerr(err)
  else
    local result = {
      pcall(luafn)
    }
    local ok = remove(result, 1)
    if not (ok) then
      return printerr(result[1])
    else
      if #result > 0 then
        print((inspect(result)):match("^%s*{%s*(.*)%s*}%s*%n?%s*$"))
        return unpack(result)
      end
    end
  end
end
local repl
repl = function(env)
  if env == nil then
    env = { }
  end
  local block = { }
  local misglobal = { }
  local get_line
  get_line = function()
    do
      local line = ln.linenoise(prompt.p .. " ")
      if line and line:match('%S') then
        ln.historyadd(line)
      end
      return line
    end
  end
  while true do
    local _continue_0 = false
    repeat
      local line = get_line()
      if not (line) then
        break
      elseif #line < 1 then
        _continue_0 = true
        break
      end
      if line:match("^:") then
        (require('moor.replcmd'))(line)
      end
      local lua_code, err = to_lua(line)
      if lua_code and not err then
        evalprint(misglobal, lua_code)
      elseif err:match("^Failed to parse") then
        insert(block, line)
        prompt.reset((function()
          do
            prompt:deepen()
            while line and #line > 0 do
              line = get_line()
              insert(block, " " .. tostring(line))
            end
            return prompt
          end
        end)())
        lua_code, err = to_lua(concat(block, "\n"))
        if lua_code then
          evalprint(misglobal, lua_code)
        end
        block = { }
      end
      if err then
        printerr(err)
      end
      _continue_0 = true
    until true
    if not _continue_0 then
      break
    end
  end
  return misglobal
end
return setmetatable({
  printerr = printerr,
  to_lua = to_lua,
  evalprint = evalprint,
  repl = repl
}, {
  __call = repl
})
